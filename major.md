## 数据结构

1、AVL tree

左右差一层

最少节点数 `S(h) = S(h-1) + S(h-2) + 1`

2、伸展树 splay

将访问的节点置于根节点上，通过旋转转移，分别为之字形，一字型（三个点）旋转，旋转后，整颗树的结构的平均深度均下降，并且由于访问时可能重复访问相同的节点，所以整体复杂度下降。

即使单次查询的复杂度为O(n)，但是会在后续的查询中摊还，整体复杂度为O（logn）。

删除时，书中写的是讲左子树中最大元素旋转到根的右节点，然后将右子树连到其右边，但我觉得旋转到根节点后连左右子树就行了。

3、B tree

应用背景，机器操作非常快，内存非常快，但是硬盘非常慢（由于是磁头转轴识别），所以应当把数据结构的层数，即检索次数降低，即使树本身变复杂，让每个父亲的孩子变多，形成B tree。

每个节点的分布为至少$\frac{m}{2} $到$m$个，根可以只有两个孩子，因为合并的时候原根超过了最大数量，被迫分成两个根，作为新根的孩子。插入和删除时，会进行分裂和合并父亲，如果不满足会递归直到根，再不满足，会造成树的深度的变化。

4、B+ tree

reference：<https://www.cnblogs.com/hzy1991/p/8567334.html>

B树，每个节点都存储key和data，所有节点组成这棵树，并且叶子节点指针为null。

B+树，只有叶子节点存储data，叶子节点包含了这棵树的所有键值，叶子节点不存储指针。

在B+树上增加了顺序访问指针，也就是每个叶子节点增加一个指向相邻叶子节点的指针，便于实现区间查询，即查询当前可以通过往后的指针访问一段区间。

数据库（Mysql）的索引使用的数据结构多为B+ tree。

5、哈希

碰撞时解决方法，1、哈希链表，2、碰撞函数（线性/平方，双散列函数）

再散列，当空间不够，声明额外空间，重新哈希

$O(1)$ 哈希的最坏查询情况

+ 完美散列

  n个物品，放入m个盒子，两个物品碰撞的概率是
  $$
  f(n)=C_n^2*\frac{m}{m*m}=\frac{n*(n-1)}{2*m}
  $$
  当$m=n^2$时，$f(n)=\frac{n-1}{2*n}<\frac{1}{2}$，即没有任何盒子装有超过一个球的概率大于$\frac{1}{2}$

  对此，直接扩大表大小，太大，联想到把哈希链表的链表替换成哈希表，即二级哈希，使用不同的散列函数直到没有冲突，且推导出二级散列表的总大小的期望为$2N$

  注意，当表中所有项已知时，该方法好用。

+ 布谷鸟散列

  装填因子$\frac{n}{m}$

  n个项被随机放入n个盒子，则盒子容量的最大期望值为$\Theta(\frac{logN}{log logN})$，当变成两倍时，期望为$\Theta(log logN)$

  布谷鸟散列，试用于装填因子小于0.5时。存在两张表，分别对应两个哈希函数，每一个物品在两个表中各自有两个位置，当插入时，先保证自己不存在于表中，然后在表1中插入，如果已经存在单位，将新物品放入，原物品到另一张表执行插入，即又碰撞会让另一个原物品换表。这样是可能死循环的，但是证明了概率相当低。可以并行查询。

+ 跳房子散列

  线性检测的优化 ，设定一个较大的基于计算机硬件的常数作为线性检测的上界，超过之后即返回替换，结合布谷鸟散列。

6、左式堆

节点维护零路径长，该点到不具两个孩子的节点的距离。性质，左孩子的零路径长大于等于右孩子的。当右边有r个节点时，左边至少有$2^r-1$个。

插入视为单节点堆合并另一个堆。合并时，递归的将有大根值与小根值的右子树合并，合并后，右子树更深，于是交换左右子树。

7、斜堆

不维护零路径长，右子树深度不管。进行左右子树交换是无条件的。最后摊还复杂度一样。





